#!/usr/bin/python



prefix = "0001FFFFFFFFFFFFFFFF003031300D060960864801650304020105C3"
len_prefix_bits = len(prefix)*4
offset_prefix = 0
middle = "04FF"
offset_middle = 190/2
message = "48ACE9B7BC30CB37338419F7716D4E9F50AA0AD2A425BCF38C2A11669F85CFD5"
offset_message = 224

total_length_bits = 8*(offset_message+len(message)/2) #normalement meme nombre de bits que N, c'est a dire ici 2048

#on cherche A,B et D tels que (prefix+B)*2^(3X)*2^D = A^3 = (C*(2^X))^3 = C^3 * 2^(3X)

def find_cube_root(n):
    m = 0
    M = n
    while m<M:
        cur = (m+M)//2
        if cur**3 < n:
            m = cur+1
        else:
            M = cur
    return m

import random

def find_cube_root_prefix(hex_prefix, total_length_bits) :
    to_compare_with = ''
    stillNull = True
    for i in range(len(hex_prefix)):
        if hex_prefix[i]=='0' and stillNull:
            pass
        elif hex_prefix[i] != '0':
            stillNull = False
        if not stillNull:
            to_compare_with += hex_prefix[i]
    to_compare_with = to_compare_with.lower()

    len_prefix_bits = len(hex_prefix)*4
    ok = False
    n_unknown_bits = 10
    while not ok and n_unknown_bits<3000:
        tmp = int(hex_prefix,16)*(2**n_unknown_bits)
        for j in range((total_length_bits-len_prefix_bits-n_unknown_bits)%3):
            tmp *= 2
        cb_sqrt = find_cube_root(int(tmp))*(2**((total_length_bits-len_prefix_bits-n_unknown_bits)//3))
        to_compare = hex(cb_sqrt*cb_sqrt*cb_sqrt).replace('0x','').replace('L','')
        if to_compare[:len(to_compare_with)] == to_compare_with:
            print("Prefix cube root found with "+str(n_unknown_bits)+" additional bits")
            break
        n_unknown_bits += 5
    return cb_sqrt

def forge_odd(hash, hash_len_bits):
    y = 1
    mask = 1
    for i in range(1, hash_len_bits):
        mask = mask | (1<<i)
        if (((y*y*y)^hash) & mask) != 0:
            y = y + (1<<i)
    return y

import math

def forge_even(hash, hash_len_bits, N):
    odd_hash = (hash+N) & ((1<<hash_len_bits)-1)
    residual = forge_odd(odd_hash, hash_len_bits)
    y = 0
    for i in range(int(math.log(N)/math.log(2)), hash_len_bits, -1):
        y = y | (1 << i)
        c = (y + residual)*(y + residual)*(y + residual)
        if (c > N) and (c < (2 * N)):
            break
        elif c > (2 * N):
            y = y & (~(1 << i))
    return (y + residual)

def forge_suffix(hex_hash, hash_len_bits, N):
    hash = int(hex_hash,16)
    if (h & 1) == 0:
        return forge_even(hash, hash_len_bits, N)
    else:
        return forge_odd(hash, hash_len_bits)

cube_root = find_cube_root_prefix(prefix, total_length_bits)
print(hex(cube_root))
print(cube_root,hex(cube_root*cube_root*cube_root))
exit()


suffix = int(message,16)
cube_root = forge_odd(suffix,len(message)*4)
print(cube_root,hex(cube_root*cube_root*cube_root))


message = "48ACE9B7BC30CB37338419F7716D4E9F50AA0AD2A425BCF38C2A11669F85CFD6"
suffix = int(message,16)
N = (1<<1024)+(1<<9)-(1<<39)-1
cube_root = forge_even(suffix,len(message)*4,N)
print(cube_root,hex(pow(cube_root,3,N)))
